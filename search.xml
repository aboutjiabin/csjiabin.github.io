<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用图标和示例解释Await和Async]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8AAwait%E5%92%8CAsync%2F</url>
    <content type="text"><![CDATA[简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。 本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。 在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task, 你会发现 promise 跟它们很像。 Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。 为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require('request-promise'); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp('http://example.com/') 我们现在来看个例子：123456console.log('Starting Execution'); const promise = rp('http://example.com/');promise.then(result =&gt; console.log(result)); console.log("Can't know if promise has finished yet..."); 我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise:123rp('http://example.com/'). then(() =&gt; console.log('Success')). catch(e =&gt; console.log(`Failed: $&#123;e&#125;`)) 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise:123456789101112const success = Promise.resolve('Resolved');// 打印 "Successful result: Resolved"success. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)) const fail = Promise.reject('Err');// 打印 "Failed with: Err"fail. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)) 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合 promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。 例如，假设我们需要编程解决如下需求： 创建 HTTP 请求，等待请求结束并打印出结果； 再创建两个并行 HTTP 请求； 等这两个请求结束后，打印出它们的结果。 下面这段代码示范了如何解决此问题：123456789101112131415// 第一次调用const call1Promise = rp('http://example.com/'); call1Promise.then(result1 =&gt; &#123; // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp('http://example.com/'); const call3Promise = rp('http://example.com/'); return Promise.all([call2Promise, call3Promise]);&#125;).then(arr =&gt; &#123; // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]);&#125;) 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。 下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。 对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async 方法Async 是定义返回 promise 对象函数的快捷方法。 例如，下面这两种定义是等价的：12345678function f() &#123; return Promise.resolve('TEST');&#125; // asyncF 和 f 是等价的async function asyncF() &#123; return 'TEST';&#125; 类似地，抛出异常的 async 方法等价于返回拒绝 promise 的方法：12345678function f() &#123; return Promise.reject('Error');&#125; // asyncF 和 f 是等价的async function asyncF() &#123; throw 'Error';&#125; Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。 然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？ 答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。 下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数：123456789async function f()&#123; // response 就是 promise 执行成功的值 const response = await rp('http://example.com/'); console.log(response);&#125; // 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log('Finished')); 现在我们来看如何解决上一节的问题：1234567891011121314151617181920212223// 将解决方法封装到 async 函数中async function solution() &#123; // 等待第一个 HTTP 请求并打印出结果 console.log(await rp('http://example.com/')); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp('http://example.com/'); // Does not wait! const call3Promise = rp('http://example.com/'); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);&#125; // 调用这一 async 函数solution().then(() =&gt; console.log('Finished')); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。 当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。 这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。 实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 我们再看看下面的例子：12345async function f() &#123; console.log('Starting F'); const result = await rp('http://example.com/'); console.log(result);&#125; 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： Await 的计算过程。 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况：1234567async function f() &#123; try &#123; const promiseResult = await Promise.reject('Error'); &#125; catch (e)&#123; console.log(e); &#125;&#125; Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise:123456789101112131415161718async function f() &#123; // Throws an exception const promiseResult = await Promise.reject('Error');&#125; // Will print "Error"f(). then(() =&gt; console.log('Success')). catch(err =&gt; console.log(err)) async function g() &#123; throw "Error";&#125; // Will print "Error"g(). then(() =&gt; console.log('Success')). catch(err =&gt; console.log(err)) 结论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() &#123; // actual return value is Promise.resolve(5) return 5;&#125; // can't call "await fAsync()". Need to use then/catchfAsync().then(r =&gt; console.log(`result is $&#123;r&#125;`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。 Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。 关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。 我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发VS并行从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。]]></content>
      <tags>
        <tag>es7</tag>
        <tag>promise</tag>
        <tag>js</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example Post using Keynote Layout]]></title>
    <url>%2F2018%2F08%2F18%2Fjs-module-7day%2F</url>
    <content type="text"><![CDATA[下滑这里查看更多内容 7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。 于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验 Watch Slides → 你也可以通过扫描二维码在手机上观看 这个 Web Slides 开源在我的 Github 上，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目 Catalog 第一日 上古时期 Module? 从设计模式说起 第二日 石器时代 Script Loader 只有封装性可不够，我们还需要加载 第三日 蒸汽朋克 Module Loader 模块化架构的工业革命 第四日 号角吹响 CommonJS 征服世界的第一步是跳出浏览器 第五日 双塔奇兵 AMD/CMD 浏览器环境模块化方案 第六日 精灵宝钻 Browserify/Webpack 大势所趋，去掉这层包裹！ 第七日 王者归来 ES6 Module 最后的战役 ThanksReveal.js]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example Post With Default Header Image]]></title>
    <url>%2F2015%2F04%2F14%2Funix-linux-note%2F</url>
    <content type="text"><![CDATA[This document is not completed and will be updated anytime. Catagory Unix Bell Labs Xenix BSD FreeBSD &amp; Apple NeXTStep Darwin POSIX Unix-like Single Unix Specification Apple iOS XNU Kernel Linux Linux Kernel GNU Project Android Android Kernel Android ROM Chrome OS Chromium OS Unix Unix is a family of multitasking, multiuser computer OS. Derive from the original AT&amp;T Unix, Developed in the 1970s at Bell Labs (贝尔实验室), initially intended for use inside the Bell System. Bell LabsBell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。C 语言也是 Bell Labs 的产物，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。 AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both academic (最有有名的 BSD ) and commercial (Microsoft Xenix, IBM AIX, SunOS Solaris) Xenix微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 Windows NT。 BSDBarkeley Software Distribution, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支) BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ） BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。 FreeBSD &amp; AppleFreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 Darwin ，这个“达尔文”居然还是个开源系统，而且是 the Core of Mac OS X and iOS. NeXTSTEPAn object-oriented, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an OO aplication layer and including several “kits”.大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 NeXTSTEP 绝对是证明 Jobs 实力的作品。 DarwinDarwin), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of POSIX. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)所以说 Mac OS X 算是很正统 Unix 的了 POSIX可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS. Fully POSIX compliant: OS X QNX OS (BlackBerry) Mostly complicant: Linux OpenBSD/FreeBSD Darwin (Core of iOS &amp; OS X) Android Complicant via compatibility feature （通过兼容功能实现兼容） Windows NT Kernel Windows Server 2000, 2003, 2008, 2008 R2, 2012 Symbian OS (with PIPS) Symbian was a closed-source OS. Unix-like A Unix-like (sometimes referred to as UNX or nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the Single UNIX Specification. There is no standard for defining the term.其实 Unix-like 是个相对模糊的概念： 最狭义的 Unix 单指 Bell Labs’s Unix 稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X 最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等 Single UNIX SpecificationThe Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to qualify for the name “Unix”, like POSIX. Apple iOSiOS is a Unix-like OS based on Darwin(BSD) and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, making iOS not fully Unix-compatible either. The iOS kernal is XNU, the kernal of Darwin. XNU KernelXNU, the acronym(首字母缩写) for X is Not Unix, which is the Computer OS Kernel developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin. Linux Linux is a Unix-like and mostly POSIX-compliant computer OS. Linux Kernel严格来讲，术语 Linux 只表示 Linux Kernel 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。 但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版） 这类操作系统也被称为 GNU/Linux GNU ProjectThe GNU Project is a free software, mass collaboration project, which based on the following freedom rights: Users are free to run the software, share (copy, distribute), study and modify it. GNU software guarantees these freedom-rights legally (via its license). So it is not only FREE but, more important, FREEDOM. In order to ensure that the entire software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, the operating system, needed to be written. This OS is decided to called GNU (a recursive acronym meaning “GNU is not Unix”). By 1992, the GNU Project had completed all of the major OS components except for their kernel, GNU Hurd. With the release of the third-party Linux Kernel, started independently by Linus Torvalds in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS composed completely of free software. Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL. Anyway, there eventually comes to the GNU/Linux GPL: GNU General Public License GCC: GNU Compiler Collection 其他与 GPL 相关的自由/开源软件公共许可证： Mozilla Public License MIT License BSD Public License GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭 Apache License AndroidAndroid is a mobile OS based on Linux Kernel, so it’s definitely Unix-like. Linux is under GPL so Android has to be open source.Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google (GMS are all proprietary) Android KernelAndroid’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches. Android’s variant of the Linux kernel has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions. Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。 Android ROM既然提到 Android 就不得不提提 Android ROM ROM 的本义实际上是只读内存： Read-only memory (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is mainly used to distribute firmware (固件) (software that is very closely tied to specific hardware, and unlikely to need frequent updates). ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash PROM (Programmable read-only memory) EPROM (Erasable programmable read-only memory) EEPROM (Electrically erasable programmable read-only memory) Flash memory (闪存) Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。 所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。 所以在 wiki 里是没有 Android ROM 这个词条的，只有 List of custom Android firmwares A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers. 各类 Android ROM 在 Android 词类下也都是属于 Forks and distributions 一类的。 所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……其实 ROM 和 Distribution OS 的界限是很模糊的，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？ Chrome OSChrome OS is an operating system based on the Linux kernel and designed by Google to work with web applications and installed applications. 虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷…… Chrome Packaged Application (Support working offline and installed) Android App Runtime (run Android applications natively…fxxking awesome) 平复一下激动的心情，还是回到正题来： Chromium OSChrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a Linux distribution designed by Google. For Detail, Chromium OS based on Gentoo Linux, emm…]]></content>
      <tags>
        <tag>OS</tag>
        <tag>Unix</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example Post]]></title>
    <url>%2F2014%2F09%2F22%2Fjs-version%2F</url>
    <content type="text"><![CDATA[JavaScript 有着很奇怪的命名史。 1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript （当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系） 歪果仁的笑话怎么一点都不好笑 译者注：wikipedia 的 JavaScript 词条 更详细的叙述了这段历史 1996 年，网景将 JavaScript 提交给 ECMA International（欧洲计算机制造商协会） 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。 术语（译者注）： 标准（Standard）： 用于定义与其他事物区别的一套规则 实现（Implementation）： 某个标准的具体实施/真实实践 不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。 译者注：ECMAScript 第四版草案由于太过激进而被抛弃，Adobe 的 ActionScript 3.0 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了） 到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015） 目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 decorators（装饰者），async-await（async-await 异步编程模型） 和 static class properties（静态类属性）。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 Babel 的官网 上查看各个提案目前都在哪个阶段了。 所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你： ECMAScript：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。 JavaScript：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。 ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。 ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。 ECMAScript 2016：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定 ECMAScript Proposals：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。 在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。 一些资源 TC39 的 Github 仓库上可以看到所有目前公开的提案 如果你还不熟悉 ES6，Babel 有一个很不错的特性概览 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 Exploring ES6和 Nicholas Zakas 的 Understanding ECMAScript 6。Axel 的博客 2ality 也是很不错的 ES6 资源 来学 JavaScript 吧！ 著作权声明本文译自 ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?译者 黄玄，首次发布于 Hux Blog，转载请保留以上链接]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example Post with Code Highlight]]></title>
    <url>%2F2013%2F05%2F25%2Fjs-module-loader%2F</url>
    <content type="text"><![CDATA[Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog CommonJS &amp; Node History RequireJS &amp; AMD SeaJS &amp; CMD AMD vs CMD WebPack 123function autoDetect()&#123; console.log('ye, it is written in JavaScript!')&#125; CommonJS &amp; Node Javascript: not just for browsers any more! —— CommonJS Slogen 前端模块化的事实标准之一，2009 年 8 月，CommonJS 诞生。 CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。 让我们看看 Node 中的实现：123456789// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper// "as though the module was wrapped in a function"var a = require('./a') // 加载模块（同步加载）a.doSomething() // 等上一句执行完才会执行exports.b = function()&#123; // 暴露 b 函数接口 // do something&#125; exports是一个内置对象，就像require是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写module.exports就可以了。 CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。 因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是： 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境） 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。 都在向着 COMMON 的方向进化：兼容不同风格，兼容浏览器和服务器两种环境 本文接下来要讨论的典例是： RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法） SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法） History 此段落参考自玉伯的 前端模块化开发那点历史 09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 Modules/1.0 规范，并且在 Node.js 等环境下取得了很不错的实践。 09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派： Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。 Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。这个稍后再细说。 Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了 补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 add和use 两个源自于 YUI Modules 的函数名替换了 define 和 require ，但其原理更接近 RequireJS ，与 YUI Modules 的 Y 沙箱 Attach 机制并不相同 RequireJS &amp; AMDAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。 RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题： As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do? 所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来 当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容： 123456define(function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); The AMD loader will parse out the require(&#39;&#39;) calls by using Function.prototype.toString(), then internally convert the above define call into this: 123456define(['require', 'dependency1', 'dependency2'], function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); 出于Function.prototype.toString()兼容性和性能的考虑，最好的做法还是做一次 optimized build AMD 和 CommonJS 的核心争议如下： 1. 执行时机Modules/1.0: 1var a = require("./a") // 执行到此时，a.js 才同步下载并执行 AMD: （使用 require 的语法糖时） 12345define(["require"],function(require))&#123; // 在这里，a.js 已经下载并且执行好了 // 使用 require() 并不是 AMD 的推荐写法 var a = require("./a") // 此处仅仅是取模块 a 的 exports&#125;) AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的） 但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。 2. 书写风格AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近： 12345define(["a", "b", "c"],function(a, b, c)&#123; // 提前申明了并初始化了所有模块 true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。&#125;) 不过，在笔者看来，风格喜好因人而异，主要还是预执行和懒执行的差异。 另外，require 2.0 也开始思考异步处理软依赖（区别于一定需要的硬依赖）的问题，提出了这样的方案： 123456// 函数体内：if(status)&#123; async(['a'],function(a)&#123; a.doSomething() &#125;)&#125; SeaJS &amp; CMDCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。 不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。 CMD Specification English (CMDJS-repo) Chinese (SeaJS-repo) CMD 主要有 define, factory, require, export 这么几个东西 define define(id?, deps?, factory) factory factory(require, exports, module) require require(id) exports Object CMD 推荐的 Code Style 是使用 CommonJS 风格的 require： 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已 12345678910111213define(function(require, exports) &#123; // 获取模块 a 的接口 var a = require('./a'); // 调用模块 a 的方法 a.doSomething(); // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露 1234567891011define('hello', ['jquery'], function(require, exports, module) &#123; // 模块代码... // 直接通过 return 暴露接口 return &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。 AMD vs CMD虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同： 对于依赖的模块，AMD 是提前执行，CMD 是懒执行。（都是先加载） CMD 推崇依赖就近，AMD 推崇依赖前置。 看代码： 12345678// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖前置，提前执行 a.doSomething() b.doSomething()&#125;) 12345678910// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') // 依赖就近，延迟执行 b.doSomething()&#125;) WebPack working…]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
